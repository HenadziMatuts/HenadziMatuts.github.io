---
layout: post
title: "RtN. Part 4:  Sound, Animation, Huffman, Github (RU)"

desc: The article is going around sound data exporting, implementing the game background animations and refactoring the game internal decompression algorithm.

author: Henadzi Matuts
date: 2018-07-23
link: https://habr.com/post/417639/
---

# Реверсим «Нейроманта». Часть 4: Звук, анимация, Хаффман, гитхаб

Привет, как вы уже поняли, это продолжение моей истории реверс-инжиниринга и портирования «Нейроманта».

<img src="https://habrastorage.org/webt/-g/ru/d_/-grud_xhetuzh4znt4rbkeakxyi.png" />

> [Реверсим «Нейроманта». Часть 1: Спрайты][1]<br>
> [Реверсим «Нейроманта». Часть 2: Рендерим шрифт][2]<br>
> [Реверсим «Нейроманта». Часть 3: Добили рендеринг, делаем игру][3]

Сегодня начнём с двух хороших новостей:
* во-первых, я больше не один - к проекту присоединился и уже успел внести ощутимый вклад пользователь @viiri;
* во-вторых, теперь у нас есть открытый репозиторий на [_github_](https://github.com/HenadziMatuts/Reuromancer).

В целом, дела идут очень неплохо и, возможно, скоро мы получим хоть сколько-то играбельный билд. А под катом, как обычно, поговорим о том, чего и _каким образом_ удалось достичь на текущий момент.

<cut />

---

Начал разбираться со звуком. Увы, но среди игровых ресурсов не оказалось ничего похожего на аудио, а поскольку я понятия не имел, как музыка работает в _MS-DOS_, было крайне непонятно, с чего начать. Почитав немного про всякие _SoundBlaster_-ы, лучшее, что я придумал, это скроллить дизассемблированный код в надежде увидеть какие-нибудь знакомые сигнатуры. А кто ищет, тот обычно находит, даже если и не совсем то, что искал (комментарии проставлены _Идой_):

```asm
sub_20416:
    ...
    mov     ax, [si+8]
    out     42h, al         ; 8253-5 (AT: 8254.2).
    mov     al, ah
    out     42h, al         ; Timer 8253-5 (AT: 8254.2).
    mov     bx, [si+0Ah]
    and     bl, 3
    in      al, 61h         ; PC/XT PPI port B bits:
                            ; 0: Tmr 2 gate ═╦═► OR 03H=spkr ON
                            ; 1: Tmr 2 data ═╝  AND 0fcH=spkr OFF
                            ; 3: 1=read high switches
                            ; 4: 0=enable RAM parity checking
                            ; 5: 0=enable I/O channel check
                            ; 6: 0=hold keyboard clock low
                            ; 7: 0=enable kbrd
    and     al, 0FCh
    or      al, bl
    out     61h, al         ; PC/XT PPI port B bits:
                            ; 0: Tmr 2 gate ═╦═► OR 03H=spkr ON
                            ; 1: Tmr 2 data ═╝  AND 0fcH=spkr OFF
                            ; 3: 1=read high switches
                            ; 4: 0=enable RAM parity checking
                            ; 5: 0=enable I/O channel check
                            ; 6: 0=hold keyboard clock low
                            ; 7: 0=enable kbrd
```

Прогуглив этот _Timer 8253-5_ я набрёл на [статью][5], ставшую первым ключом к пониманию происходящего. Ниже я постараюсь объяснить, что к чему.

Так вот, в эпоху _IBM-PC_, до появления доступных звуковых карт, наиболее распространённым устройством воспроизведения звука был так называемый _PC Speaker_, также известный как «бипер». Это устройство есть не что иное, как обычный динамик, подключавшийся к материнской плате, в большинстве случаев, через четырёхпиновый разъём. Бипер, по задумке, позволял воспроизводить двухуровневый прямоугольный импульс (соответствующий двум уровням напряжения, обычно это 0V и +5V) и управлялся через 61-й порт контроллера _PPI (Programmable Peripheral Interface)_. Конкретно за управление «спикером» отвечают первые два бита посылаемого в порт значения (смотри комментарии к строкам `in al, 61h` и `out 61h, al`).

Как я уже сказал (немного другими словами), наш динамик может находиться в двух состояниях - _«in»_ и _«out»_ (_«low»-«high»_, _«off»-«on»_, _«выкл»-«вкл»_, как угодно). Для создания _одного_ импульса, необходимо изменить текущее состояние на противоположное и, через некоторое время, обратно. Это можно сделать напрямую, манипулируя первым битом (считаем с нуля) 61-го порта, например, так:

```asm
PULSE:
    in      al, 61h         ; получаем исходное значение
    and     al, 11111100b   ; зануляем первые два бита...
    or      al, 00000010b   ; и устанавливаем первый в единицу...
                            ; ВАЖНО, что нулевой бит должен быть установлен в 0
    out     61h, al         ; пишем значение в 61-й порт
    mov     cx, 100         ; заводим цикл
DELAY:
    loop    DELAY           ; ждём некторое время
    in      al, 61h         ; получаем исходное значение
    and     al, 11111100b   ; зануляем первые два бита
    out     61h, al         ; пишем значение в 61-й порт
```

Результат выполнения этого кода будет выглядеть cледующим образом:

```asm
              loop DELAY
+5V    +----------------------+
       !                      !
 0V ---+                      +--------------------------
       or  al, 00000010b      and al, 11111100b
       out 61h, al            out 61h, al
```

Повторяя _PULSE_ с задержкой, мы получим прямоугольный сигнал:

```asm
    mov     dx, 100     ; генерируем 100 импульсов
PULSE:
    ...

    mov     cx, 100
WAIT:
    loop    WAIT
    dec     dx
    jnz     PULSE

          PULSE
+5V    +---------+         +---------+         +---------+
       !         !         !         !         !         !
 0V ---+         +---------+         +---------+         +---
                  loop WAIT

```

Если в первом случае мы бы вряд ли что-нибудь услышали, то во втором мы получим тон частоты, зависящей от скорости машины, на которой выполняется этот код. Это здорово, но связано с определёнными сложностями. В любом случае, есть и более удобный способ управления динамиком.

Тут в игру вступает программируемый трёхканальный таймер - _Intel 8253_, второй канал которого (начиная с нулевого) подключен к биперу. Этот таймер принимает сигнал от микросхемы тактового генератора _Intel 8254_, посылающей 1193180 импульсов в секунду (~1.193 МГц), и может быть запрограммирован на определённую реакцию по истечении задаваемого количества импульсов. Одна из таких реакций - отправка прямоугольного импульса на динамик. Иными словами, _8253_ может работать в режиме генератора прямоугольного сигнала регулируемой частоты, это позволяет относительно просто синтезировать на спикере различные звуковые эффекты. И вот, что для этого нужно:

1. Установить второй канал таймера в режим генерации прямоугольного сигнала. Для этого нужно записать специальное однобайтовое значение в порт 43 (_8253 Mode/Command register_). В моём случае - это `10110110B` (подробнее [здесь](https://wiki.osdev.org/Programmable_Interval_Timer)):

```markdown
Bits         Usage
 6 and 7      Select channel :
                 1 0 = Channel 2
 4 and 5      Access mode :
                 1 1 = Access mode: lobyte/hibyte
 1 to 3       Operating mode :
                 0 1 1 = Mode 3 (square wave generator)
 0            BCD/Binary mode:
                 0 = 16-bit binary
```

2. Задать на втором канале нужную частоту. Для этого побайтно, от младшего к старшему, отправляем в 42-й порт (_8253 Channel 2 data port_) значение, равное `1193180 / freq`, где `freq` - это требуемое значение частоты в Герцах.

3. Позволить динамику принимать импульсы от таймера. Для этого устанавливаем в единицу первые два бита значения в порту 61 (_PPI_). Дело в том, что, если нулевой бит установлен в 1, то первый интерпретируется как «переключатель»:

```markdown
Bit 0    Effect
-----------------------------------------------------------------
  0      The state of the speaker will follow bit 1 of port 61h
  1      The speaker will be connected to PIT channel 2, bit 1 is
         used as switch ie 0 = not connected, 1 = connected.
```

В итоге, имеем следующую картину:

```asm
    mov     al, 10110110b
    out     43h, al         ; инициализируем таймер

    mov     ax, 02E9Bh      ; 1193180 / 100Гц = ~0x2E9B
    out     42h, al         ; пишем младший байт делителя частоты
    mov     al, ah
    out     42h, al         ; пишем старший байт делителя частоты

    in      al, 61h         ; получаем исходное значение
    or      al, 00000011b   ; устанавливаем первые два бита в 1
    out     61h, al         ; включаем динамик

    ...                     ; некоторое время слушаем тон на частоте ~100 Гц

    in      al, 61h
    and     al, 11111100b
    out     61h, al         ; выключаем динамик
```

И это именно то, что делает код, который я привёл в самом начале (кроме инициализации, но её я нашёл в другой функции): по адресу `si + 8` находится делитель частоты, отправляемый в 42-й порт, а по адресу `si + 0Ah` - состояние динамика (_«вкл»-«выкл»_), записываемое в порт 61.

Механизм воспроизведения прост и понятен, но дальше нужно было разобраться с таймингами. Изучив близлежащий код, я увидел, что в той же функции, в которой инициализизируется таймер (`sub_2037A`, далее - `init_8253`), происходит подмена обработчика [восьмого прерывания (_Time of Day_)][8] на функцию `sub_20416` (далее - `play_sample`). Вскоре выяснилось, что это прерывание генерируется примерно 18.2 раза в секунду и служит для обновления системного времени. Подмена обработчика этого прерывания - распространённая практика, если нужно выполнять некоторое действие 18 раз в секунду (на самом деле, внутри хука также необходимо вызывать оригинальный обработчик, иначе остановится системное время). Исходя из этого получается, что очередная частота заряжается в генератор каждые `(1 / 18.2) * 1000 ~ 55мс`.

План был такой:
* поставить брейкпоинт в функции `play_sample`, на строчке, где извлекается очередной делитель частоты;
* вычислить частоту по формуле `freq = 1193180 / divisor`;
* сгенерировать 55мс прямоугольного сигнала частоты `freq` в каком-нибудь аудиоредакторе (я использовал _Adobe Audition_);
* повторять первые три шага до накопления хотя бы 3-х секунд.

Так я получил начало мелодии из главного меню, но играющее раз эдак в 10 медленнее, чем нужно. Тогда я сократил длительность «сэмпла» с 55 мс до 5 мс - стало гораздо лучше, но всё ещё не то. Вопрос с таймингами оставался открытым, пока я не нашёл вот [эту статью][9]. Оказалось, что восьмое прерывание генерируется с подачи всё того же _8253_, нулевой канал которого подключен к контроллеру прерываний (_PIC_). Во время загрузки машины _BIOS_ настраивает нулевой канал на генерацию импульсов с частотой ~18.2 Гц (то есть прерывание генерируется каждые ~54.9 мс). Однако нулевой канал можно перепрограммировать так, чтобы он генерировал импульсы с большей частотой, для этого, по аналогии со вторым каналом, в 40-й порт нужно записать значение, равное `1193180 / freq`, где `freq` - это требуемое значение частоты в Герцах. Это и происходит в функции `init_8253`, просто изначально я не обратил на это должного внимания:

```asm
init_8253:
    ...
    mov     al, 0B6h        ; 10110110b
    out     43h, al         ; Timer 8253-5 (AT: 8254.2).
    mov     ax, 13B1h
    out     40h, al         ; Timer 8253-5 (AT: 8254.2).
    mov     al, ah
    out     40h, al         ; Timer 8253-5 (AT: 8254.2).
```

Значение `13B1h` переводим в частоту: `1193180 / 13B1h ~ 236.7Гц`, тогда получаем примерно `(1 / 236.7) * 1000 ~ 4.2мс` на «сэмпл». Пазл сложился.

Дальше уже дело техники - реализовать функцию, извлекающую звуковые дорожки из игры. Но вот в чём дело, значения делителей частоты, записываемые в 42-й порт, не хранятся в явном виде. Они вычисляются неким хитрым алгоритмом, входные данные и рабочая область которого лежат прямо в исполняемом файле игры (в седьмом сегменте по версии _Иды_). Ещё, из особенностей, здесь не предусмотрено признака окончания трека, когда играть больше нечего, алгоритм бесконечно выдаёт нулевое состояние динамика. Но я не стал заморачиваться и, как и в случае с алгоритмом декомпрессии ([первая часть][1]), просто портировал на 64-битный ассемблер функцию установки трека на воспроизведение и алгоритм получения очередной частоты (а седьмой сегмент я забрал целиком).

И это сработало. После, я реализовал функции генерации звуковой дорожки для выбранного трека (_PCM, 44100 Hz, 8 bit, mono_; сделал нечто наподобие генератора, используемого в эмуляторе спикера в _DosBox_). Проблему с признаком окончания я решил простым счётчиком тишины: насчитали секунду - завершаем алгоритм. Завернув полученную дорожку в _WAV_-заголовок и сохранив результат в файл, я получил в точности трек из главного меню. И ещё 13 треков, которые вы можете прослушать ниже _[или в просмотрщике ресурсов, в котором теперь есть встроенный плеер и возможность сохранить любой трек в .WAV]_:

<oembed>https://soundcloud.com/gennadiy-aiz/sets/neuromancer-sounds-ms-dos-1988</oembed>

_[Изучая вопрос, я узнал и про более продвинутые техники «игры на бипере», вроде использования широтно-импульсной модуляции для низкокачественного воспроизведения PCM-звука. В конце этой статьи я приведу список материалов, из которых можно узнать больше.]_

---

Во [второй части][2], когда рассматривались различные форматы ресурсов, я предположил, что в _.ANH_-файлах лежат анимации для бэкграундов локаций (то есть для изображений, хранящихся в _.PIC_). _[Это так.]_ Закончив со звуком, я решил это проверить. Чисто исходя из предположения, что анимация применяется прямо на изображение задника, хранящееся в памяти (не в _видеопамяти_, а в _спрайт-чейне_), я решил сделать дампы этой памяти соответственно до и после применения анимации (смотрим туда, куда указывает курсор - на верхнюю строку буквы 'S'):

<img src="https://habrastorage.org/webt/zp/9a/qn/zp9aqnvcvi-gn3pp0t1puzvhpti.gif" width="32%" height="32%" /> <img src="https://habrastorage.org/webt/jz/9l/ig/jz9ligummo9j_xwwatid-s0vcri.png" width="32%" height="32%"/> <img src="https://habrastorage.org/webt/sz/pd/uy/szpduyzc7lgsqum_np9sbvrq4qo.png" width="32%" height="32%"/>

```markdown
3DE6:0E26     03 B4 44 B3 ...   ; первый кадр
3DE6:0E26     03 BC CC B3 ...   ; второй кадр
```

Именно то, чего я ожидал - тёмно-красный цвет (0x4) сменился на ярко-красный (0xC). Теперь можно попробовать поставить брейкпоинт на изменение значения по адресу, например, `3DE6:0E28` и, если повезёт, провести обратную трассировку. _[Мне повезло.]_ Точка останова привела меня к строке, непосредственно изменяющей значение по заданному адресу: `xor es:[bx], al`. Осмотрев окресности, я без особого труда построил цепочку вызовов от основного цикла уровня до этого момента: `sub_1231E (xor es:[bx], al) <- sub_12222 <- sub_105F6 <- sub_1038F (основной цикл)`.

Я уже не буду вдаваться в подробности о том, как именно я реверсил процесс анимирования. Это достаточно рутинная и методичная работа, однако не очень сложная, если чётко очерчены границы (полученный бэктрейс и есть эти границы). Но я не могу не рассказать о том, что же получилось в итоге.

Сперва об _.ANH_-формате. По сути, он представляет из себя набор контейнеров, и первым вордом в _.ANH_-файле идёт количество контейнеров внутри:

```cpp
typedef struct anh_hdr_t {
    uint16_t anh_entries;
    /* first entry hdr */
} anh_hdr_t;
```

Сам по себе контейнер - это отельно взятая анимация элемента заднего фона. У контейнера можно выделить заголовок, содержащий его байтовый размер и количество кадров в анимации, которую он представляет. Следом за заголовком попарно идут значения длительности (задержки) очередного кадра и смещение байтов самого кадра, относительно байтов первого кадра. Количество таких пар, очевидно, равно количеству кадров:

```cpp
typedef struct anh_entry_hdr_t {
    uint16_t entry_size;
    uint16_t total_frames;
    /* anh_frame_data_t first_frame_data */
    /* another frames data */
    /* anh_frame_hdr first_frame_hdr */
    /* another frames */
} anh_entry_hdr_t;

typedef struct anh_frame_data_t {
    uint16_t frame_sleep;
    uint16_t frame_offset;
} anh_frame_data_t;

...

extern uint8_t *anh;

anh_hdr_t *hdr = (anh_hdr_t*)anh;
anh_entry_hdr_t *entry = (anh_entry_hdr_t*)(anh + sizeof(anh_hdr_t));

for (uint16_t u = 0; u < anh->anh_entries; u++)
{
    uint8_t *p = (uint8_t*)entry;
    anh_frame_data_t *first_frame_data =
        (anh_frame_data_t*)(p + sizeof(anh_entry_hdr_t));
    uint8_t *first_frame_bytes =
        p + (entry->total_frames * sizeof(anh_frame_data_t));

    for (uint16_t k = 0; k < entry->total_frames; k++)
    {
        anh_frame_data_t *frame_data = first_frame_data + k;
        uint8_t *frame_bytes = first_frame_bytes + frame_data->frame_offset;
        ...
    }

    /* plus 2 bytes of padding */
    p += (entry->entry_size + 2);
    entry = (anh_entry_hdr_t*)p;
} 

```

Отдельный же кадр состот из четырёхбайтного заголовка, содержащего его линейные размеры и смещения относительно изображения заднего фона, и пикселей кадра, закодированных уже знакомым мне _Run Length_ алгоритмом:

```cpp
typedef struct anh_frame_hdr {
    uint8_t bg_x_offt;
    uint8_t bg_y_offt;
    uint8_t frame_width;
    uint8_t frame_height;
    /* rle encoded frame bytes */
};
```

«Наложение» кадра на задник может выглядеть следующим образом:

```cpp
extern uint8_t *level_bg;

uint8_t frame_pix[8192];
anh_frame_hdr *hdr = (anh_frame_hdr*)frame_bytes;

uint16_t frame_len = hdr->frame_width * hdr->frame_height;
decode_rle(frame + sizeof(anh_frame_hdr), frame_len, frame_pix);

/* 0xFB4E - some magic value, have no idea what is it */
uint16_t bg_offt = (hdr->bg_y_offt * 152) + hdr->bg_x_offt + 0xFB4E;
uint16_t bg_skip = 152 - hdr->frame_width;

uint8_t *p1 = frame_pix, *p2 = level_bg;

for (uint16_t i = hdr->frame_height; i != 0; i--)
{
    for (uint16_t j = hdr->frame_width; j != 0; j--)
    {
        *p2++ ^= *p1++;
    }

    p2 += bg_skip;
}
```

Таков _.ANH_-формат, но есть ещё одна структура, заставляющая всё это работать:

```cpp
typedef struct bg_animation_control_table_t {
    uint16_t total_frames;
    uint8_t *first_frame_data;
    uint8_t *first_frame_bytes;
    uint16_t sleep;
    uint16_t curr_frame;
} bg_animation_control_table_t;
```

В самой игре глобально объявлен массив как минимум из четырёх структур такого вида. После загрузки очередного _.ANH_-файла, количество анимаций внутри также сохраняется в глобальную переменную, а элементы массива инициализируются следующим образом:

```cpp
extern uint8_t *anh;

uint16_t g_anim_amount = 0;
bg_animation_control_table_t g_anim_ctl[4];

...

anh_hdr_t *hdr = (anh_hdr_t*)anh;
anh_entry_hdr_t *entry = (anh_entry_hdr_t*)(anh + sizeof(anh_hdr_t));

g_anim_amount = hdr->anh_entries;

for (uint16_t u = 0; u < g_anim_amount; u++)
{
    uint8_t *p = (uint8_t*)entry;

    g_anim_ctl[u].total_frames = entry->total_frames;
    g_anim_ctl[u].first_frame_data = p + sizeof(anh_entry_hdr_t);
    g_anim_ctl[u].first_frame_bytes = g_anim_ctl[u].first_frame_data +
        (entry->total_frames * sizeof(anh_frame_data_t));
    g_anim_ctl[u].sleep = *(uint16_t*)(g_animation_control[u].first_frame_data);
    g_anim_ctl[u].curr_frame = 0;

    /* plus 2 bytes of padding */
    p += (entry->entry_size + 2);
    entry = (anh_entry_hdr_t*)p;
}

```

Наконец, применяем анимации:

```cpp
for (uint16_t u = 0; u < g_anim_amount; u++)
{
    bg_animation_control_table_t *anim = &g_anim_ctl[u];

    if (anim->sleep-- == 0)
    {
        anh_frame_data_t *data =
            (anh_frame_data_t*)anim->first_frame_data + anim->curr_frame;

        /* Накладываем очередной кадр */
        ...

        if (++anim->curr_frame == anim->total_frames)
        {
            anim->curr_frame = 0;
            data = (anh_frame_data_t*)anim->first_frame_data;
        }
        else
        {
            data++;
        }

        anim->sleep = data->frame_sleep;
    }
}
```

И получаем следующее _[гораздо больше можно посмотреть в просмотрщике ресурсов]_:

<img src="https://habrastorage.org/webt/p7/lv/fn/p7lvfn5ytpjm5nsoctsumdncuaa.gif" />

<img src="https://habrastorage.org/webt/j6/nb/xp/j6nbxpj29jlrikbmjl8f62s4xmc.gif" />

На данный момент с анимацией есть пара проблем. Первая заключается в том, что в своём коде я проигрываю все имеющиеся анимации, однако оригинал проверяет некие глобальные флаги, указывающие нужно ли прокручивать очередную. И вторая, связанная с тем, что некоторые анимации добавляют на экран объекты, которых изначально там нет. А поскольку кадры «ксорятся» на бэкграунд, то при циклическом прокручивании, на каждом втором круге объект просто пропадает. Вот, например, как это может выглядеть:

<img src="https://habrastorage.org/webt/d3/5l/iu/d35liujvu6ash9gcdrecvoq9kuc.gif" />

Но пока оставим всё как есть. 

---

Помните неизвестный алгоритм декомпрессии из [первой части][1]? Едва только подключившись к разработке, @viiri не только определил, что именно это за алгоритм, но и написал свой вариант декодера, заменивший в кодовой базе ужасный трёхсотстрочный кусок Ассемблера. В связи с этим, я попросил @viiri написать небольшой очерк о проделанной работе. Что и было сделано, но перед тем, как я его приведу, пару слов нужно сказать о теории.

Для сжатия ресурсов разработчики _«Нейроманта»_ использовали [_код Хаффмана_][12]. Это один из первых эффективных методов кодирования информации, использующий [_префиксные коды_][13]. В теории кодирования _префиксными_ называют коды со словом переменной длины и такие, в которых ни одно кодовое слово не является префиксом другого. То есть, если в состав префиксного кода входит слово _«a»_, то слова _«ab»_ в коде не существует. Это свойство позволяет однозначно разбивать на слова сообщение, закодированное таким кодом.

Идея алгоритма Хаффмана состоит в том, что, зная вероятности появления символов некоторого алфавита в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью появления ставятся в соответствие более короткие коды, а символам с меньшей вероятностью - наоборот, более длинные. В целом, процедура кодирования сводится к построению оптимального кодового дерева и, на его основе, отображению символа сообщения на соответствующий код. Свойство префиксности полученного кода позволяет однозначно декодировать сжатое им собщение.

<img src="https://habrastorage.org/webt/fa/is/hb/faishbcvf0flxiao-mfmnx3llvu.gif" />

У алгоритма есть один существенный недостаток (на самом деле не один, но сейчас важен только этот). Дело в том, что для того, чтобы восстановить содержимое сжатого сообщения, декодер должен знать таблицу частот появления символов, которой пользовался кодер. В связи с этим, вместе с закодированным сообщением должна передаваться либо таблица вероятностей, либо само кодовое дерево (вариант, используемый в игре). Размеры дополнительных данных могут быть относительно велики, а это существенно бъёт по эффективности сжатия.

Кое-что о том, как с этим можно бороться, а так же про свой декодер и тот, который реализован в игре, рассказывает @viiri:

> Сразу стоит упомянуть, что вся игра была полностью написана на Ассемблере, руками, поэтому код содержит интересные решения, трюки и оптимизации.

> По процедурам. Функция `sub_1ff94` (`build_code_table`) нужна для загрузки из файла сжатого дерева Хаффмана. Для декодирования статического Хаффмана (бывает и [динамический][14], и на него это требование не распространяется) вместе с сообщением нужно передать кодовое дерево, которое представляет из себя сопоставление кодов Хаффмана реальным кодам символов. Это дерево достаточно большое и поэтому неплохо бы и его как-нибудь эффективно хранить. Наиболее правильный способ - использование [канонических кодов][15] ([MOAR][16]). Благодаря их свойствам, существует очень интересный и эффективный способ хранения дерева (используется в реализации метода сжатия _Deflate_ архиватора _PKZip_). Но в игре канонические коды не используются, вместо этого осуществляется [прямой обход дерева][17] и для каждой вершины в выходной поток записывается бит 0, если узел не является листом, или бит 1, если узел является листом, и тогда следующие 8 бит являются кодом символа в этом узле. При декодировании осуществляется аналогичный обход дерева, который мы и видим в игре. [Тут][18] есть пример и некоторое объяснение.

```asm
build_code_table proc near
    call    getbit              ; читаем бит из потока
    jb      short loc_1FFA9     ; нашли листовой узел...
    shl     dx, 1
    inc     bx
    call    build_code_table    ; вызываем build_code_table для левого поддерева
    or      dl, 1
    call    build_code_table    ; вызываем build_code_table для правого поддерева
    shr     dx, 1
    dec     bx
    ret
loc_1FFA9:
    call    sub_1FFC2           ; читаем код символа из потока (8 бит)
    ...                         ; сохраняем значение в таблице
    ret
sub_1FF94 endp

sub_1FFC2 proc near
    sub     di, di
    mov     ch, 8
loc_1FFC6:
    call    getbit
    rcl     di, 1
    dec     ch
    jnz     short loc_1FFC6
    retn
sub_1FFC2 endp
```

> `getbit` (`sub_1ffd0`) осуществляет чтение бита из потока входных данных. Её анализ позволяет заключить, что отдельные биты выделяются из 16-битного регистра `ax`, значение в который загружается из памяти инструкцией `lodsw`, которая грузит два байта из потока, но так как процессор _Intel_ имеет порядок байт _little-endian_, то `xchg` переставляет половины регистра. Далее, порядок битов в потоке на вид несколько нелогичен - первым является не младший, а старший бит. Это сделано потому, что инструкция `shl` выталкивает старший бит во флаг переноса, который потом удобно проверять командой условного перехода `jb`.

```asm
getbit proc near
    or      cl, cl
    jz      short loc_1FFD9
    dec     cl
    shl     ax, 1
    retn

loc_1FFD9:
    cmp     si, 27B6h
    jz      short loc_1FFE7     ; закончились данные
    lodsw
    xchg    al, ah
    mov     cl, 0Fh
    shl     ax, 1
    retn

loc_1FFE7:
    call    sub_202FC           ; дочитываем из файла очередную порцию
    lodsw
    xchg    al, ah
    mov     cl, 0Fh
    shl     ax, 1
    retn
getbit endp
```

На этой основе @viiri реализовал простой, но отлично работающий декодер:

```cpp
typedef struct node_t {
    uint8_t value;
    struct node_t *left, *right;
} node_t;

static uint8_t *g_src = NULL;

static int getbits(int numbits)
{
    ...
}

static uint32_t getl_le()
{
    /* размер декодированного файла
       хранится в первых 4-х байтах
       входного потока
     */
}

static node_t* build_tree(void)
{
    node_t *node = (node_t*)calloc(1, sizeof(node_t));

    if (getbits(1)) {
        node->right = NULL;
        node->left = NULL;
        node->value = getbits(8);
    }
    else {
        node->right = build_tree();
        node->left = build_tree();
        node->value = 0;
    }

    return node;
}

int huffman_decompress(uint8_t *src, uint8_t *dst)
{
    int length, i = 0;
    node_t *root, *node;

    g_src = src;
    length = getl_le();
    node = root = build_tree();

    while (i < length)
    {
        node = getbits(1) ? node->left : node->right;
        if (!node->left) {
            dst[i++] = node->value;
            node = root;
        }
    }
    ...
}

```

Однако в самой игре всё гораздо интереснее:

> На самом деле `build_code_table` рекурсивно строит таблицу Хаффмана. Это очень удобно при кодировании, потому что кодируемый символ является индексом этой самой таблицы, и за константное время для любого символа можно получить его префиксный код и длину этого кода. При декодировании таблица не эффективна, так как при получении из потока каждого бита необходимо перебирать все записи таблицы в поисках совпавшего кода. Для декодирования больше подходит дерево, так как с каждым новым битом из входного потока можно определять, в какой узел идти, и как только он окажется листом - символ декодирован (что и сделано в `huffman_decompress`).

> Зачем же тогда декодеру таблица? Правильно! Чтобы по ней построить ещё одну таблицу! Суть [идеи][19] проста, но несколько неочевидна. Алгоритм основан на свойстве префиксных кодов (_условие Фано_): никакое кодовое слово не может быть началом другого кодового слова. Допустим, что длина слова некоторого префиксного кода не превышает 3-х бит, в этом случае три бита входного потока содержат _N_ бит кода, а _(3 - N)_ бит являются началом следующего слова.

Возьмём следующий префиксный код для алфавита `ABCD`: `A - 0b, B - 10b, C - 110b, D - 111b`. Сдвинем коды символов до упора влево (в трёхбитном слове), и занесём в таблицу получившийся код, длину кода и соответсвующий символ:

Код      | Длина | Символ
-------- | ----- | ------
**0**00b | 1     | A
**10**0b | 2     | B
**110**b | 3     | C
**111**b | 3     | D

Считывая по три бита из входного потока, мы можем использовать итоговое значение как индекс в этой таблице для быстрого получения соответствующего символа. Но что, если, например, мы прочитаем из потока значение `010b` - такого кода в таблице нет. И вот тут себя проявляет свойство префиксности. Ведь то, что символу 'A' соответсвует код `0b` означает, что оставшимся символам алфавита _не может_ соответствовать код, начинающийся с нулевого бита. Тогда таблица дополняется следующим образом:

Индекс | Код      | Длина | Символ
------ | -------  | ----- | ------
0      | **0**00b | 1     | A
1      | **0**01b | 1     | A
2      | **0**10b | 1     | A
3      | **0**11b | 1     | A
4      | **10**0b | 2     | B
5      | **10**1b | 2     | B
6      | **110**b | 3     | C
7      | **111**b | 3     | D

Допустим, есть входная последовательность `011010111b`:
* считываем три бита в буфер: `011b`;
* из таблицы, по индексу `011b (3)`, получаем символ `A`, записываем его в выходной поток;
* длина кода `011b` по таблице равна 1, значит, сдвигаем значение в буфере на один бит влево и дочитываем в освободившийся разряд один бит из потока: `110b`;
* из таблицы, по индексу `110b (6)`, получаем символ `С`, записываем его в выходной поток;
* и так далее, пока входной поток не опустеет.

В «Нейроманте» в качестве индекса используется 8-битное значение. То есть генерируется таблица из 256 элементов. Однако максимальная длина слова в используемом коде значительно превышает 8 бит. В этом случае, с целью экономии памяти, используются подтаблицы:

> В случае наличия кодов с длиной больше байта тоже всё просто: введём дополнительное поле в таблицу - номер подтаблицы, в которую нужно перейти для декодирования оставшейся части длинного кода. Чем длиннее коды, тем больше подтаблиц понадобится. Игра использует 4 - хватит для 32-битных кодов.

Вот примерно так работает декодер, представленный в игре. Дело закрыто.

---

Как и было сказано в самом начале, исходники проекта теперь доступны на [_github_][4]. Для просто интересующихся и тех, кто захочет принять участие в его развитии, я расскажу немного о том, что же всё-таки там лежит _[немного подробнее, чем написано в README.md]_.

По факту, там лежат три проекта, объединённые в один солюшен 2015-й студии:

* _LibNeuroRoutines (Си, MASM)_ - библиотека, вмещающая в себя различные алгоритмы общего назначения, реверснутые из оригинальной игры. Заголовочный файл библиотеки (`neuro_routines.h`) постоянно пополняется и содержит все известные на сегодняшний день структуры данных, используемые в игре. Там же объявлены экспортируемые функции, реализующие:
  - декомпрессию ресурсов (`huffman_decompression.c`, `decompression.c`);
  - работу с текстом (`cp437.c`);
  - работу с диалоговыми окнами (`dialog.c`);
  - работу со звуком (`audio.c`).
* _NeuromancerWin64 (Си)_ - собственно движок и сама игра. На данный момент имеет мало общего с оригиналом в плане внутренней организации и является лишь прототипом. В дальнейшем планируется уточнять реализацию, сделав её максимально близкой к настоящему _«Нейроманту»_, но с некоторыми допущениями, вроде плавной анимации и более удобного управления. В качестве мультимедийного бэкенда сейчас используется _CSFML_ (биндинги _SFML_ для языка _C_).
* _ResourceBrowser (C++)_ - просмотрщик ресурсов. Представляет из себя _MFC_-приложение, позволяющее просматривать и экспортировать различные ресурсы из оригинальных _.DAT_-файлов. Прямо сейчас оно позволяет:
  - просматривать и экспортировать в _BMP (8bpp)_ графику (вкладки _IMH_, _PIC_);
  - просматривать анимации (вкладка _ANH_);
  - прослушивать и экспортировать в _WAV (PCM, 44100Hz, 8bps, mono)_ аудиодорожки (вкладка _SOUND_).

Из вышеперечисленного только _LibNeuroRoutines_ является самостоятельным проектом. Остальные зависят от _LibNeuroRoutines_ и _CSFML_ (в _ResourceBrowser_ с помощью _SFML_ сделан встроенный аудиоплеер).

Пока проект может работать только под 64-битной _Windows_ и на то есть причина. Дело в том, что исходники _LibNeuroRoutines_ содержат 64-битный _MASM (Microsoft Macro Assembler)_. Этот код - куски листинга из дизассемблера, подогнанные до рабочего состояния на 64-битной системе. Да, я бы мог использовать кроссплатформенный _NASM_ или _FASM_, но мне было важно, чтобы этот код без лишних телодвижений можно было отлаживать прямо в среде разработки. А поскольку я работаю в _VS 2015_ - _MASM_ был единственной опцией.   

На самом деле это временная мера, просто чтобы работало. В дальнейшем весь Ассемблер должен быть переписан на _C_. И как только это случится, уже ничего не будет препятствовать портированию проекта на другие платформы (кроме просмотрщика ресурсов, он на _MFC_).

Пока это всё, что я хотел рассказать по этому поводу. Если есть какие-либо вопросы, то я постараюсь на них ответить.

---

С выходом этой статьи я очень сильно опередил свой обычный темп. Когда следующая? Вероятно, не скоро. Сейчас мы планируем сосредоточиться на разработке и довести до ума те вещи, которые уже сделаны. Но если появятся что-то интересное, то мы обязательно об этом расскажем. Ниже, как я и обещал, список материалов по программированию спикера, а под ним небольшой опрос. До (не)скорого.

1. [Make sound from the speaker using assembly](http://www.intel-assembler.it/portale/5/make-sound-from-the-speaker-in-assembly/8255-8255-8284-asm-program-example.asp)
2. [Programming the PC Speaker](http://www.intel-assembler.it/portale/5/Programming-the-PC-Speaker/Programming-the-PC-Speaker-8253-8254.asp)
3. [PC Speaker](https://wiki.osdev.org/PC_Speaker)
4. [Programmable Interval Timer](https://wiki.osdev.org/Programmable_Interval_Timer)
5. [Making C Sing](https://books.google.by/books?id=aAtUrtU87kQC&lpg=PT422&dq=playing%20music%20with%208253%20timer&pg=PT422#v=onepage&q&f=false)
6. [Beyond Beep-Boop: Mastering the PC Speaker](https://bumbershootsoft.wordpress.com/2016/12/10/beyond-beep-boop-mastering-the-pc-speaker/)

[1]: /2018/03/30/reversing-the-neuromancer-part-1.html
[2]: /2018/05/10/reversing-the-neuromancer-part-2.html
[3]: /2018/07/05/reversing-the-neuromancer-part-3.html
[4]: https://github.com/HenadziMatuts/Reuromancer
[5]: http://www.intel-assembler.it/portale/5/make-sound-from-the-speaker-in-assembly/8255-8255-8284-asm-program-example.asp
[6]: https://wiki.osdev.org/Programmable_Interval_Timer
[7]: http://www.intel-assembler.it/portale/5/Programming-the-PC-Speaker/Programming-the-PC-Speaker-8253-8254.asp
[8]: http://assemblytutorial.blogspot.com/2010/09/interrupt-8-time-of-day.html
[9]: https://books.google.by/books?id=aAtUrtU87kQC&lpg=PT422&dq=playing%20music%20with%208253%20timer&pg=PT422#v=onepage&q&f=false
[10]: https://wiki.osdev.org/PC_Speaker
[11]: https://bumbershootsoft.wordpress.com/2016/12/10/beyond-beep-boop-mastering-the-pc-speaker/
[12]: https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0
[13]: https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4
[14]: https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0
[15]: https://www.sciencezero.org/index.php?title=Huffman_coding#Storing_the_Huffman_tree_efficiently
[16]: https://en.wikipedia.org/wiki/Canonical_Huffman_code
[17]: https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%85%D0%BE%D0%B4_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0#%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B9_%D0%BE%D0%B1%D1%85%D0%BE%D0%B4_(NLR)
[18]: https://stackoverflow.com/questions/759707/efficient-way-of-storing-huffman-tree
[19]: http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art007